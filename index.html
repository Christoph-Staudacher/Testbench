<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>PLZ-Karte mit Airtable Status & Rate Limit Handling</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    crossorigin=""
  />
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
    }
    #map {
      width: 100%;
      height: 90vh;
    }
    #plz-search {
      padding: 10px;
      background: #f8f8f8;
      font-family: sans-serif;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }
    .plz-label {
      font-size: 12px;
      font-weight: bold;
      background: transparent;
      padding: 0;
      border: none;
      color: #333;
    }
    #marker-info,
    #debug-info {
      font-size: 12px;
      color: #555;
    }
    .status-button {
      margin: 2px;
      padding: 3px 5px;
      font-size: 11px;
      cursor: pointer;
      border: 1px solid #999;
      background: #eee;
    }
    /* Ladekreis */
    #loading-spinner {
      width: 14px;
      height: 14px;
      border: 2px solid #999;
      border-top: 2px solid transparent;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-left: 8px;
      display: none;
    }
    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
  </style>
</head>
<body>
  <div id="plz-search">
    <label for="plzInput">PLZ eingeben:</label>
    <input type="text" id="plzInput" placeholder="z.B. 83052" />
    <button onclick="zoomToPLZ()">Suchen</button>

    <label><input type="checkbox" id="unknownMarkerToggle" /> Unbekannte Marker anzeigen</label>
    <label><input type="checkbox" id="tttnMarkerToggle" checked /> Marker in TT/TN-PLZ anzeigen</label>

    <div id="marker-info"></div>
    <div id="debug-info">
      Daten geladen:
      <span id="debug-text">–</span>
      <div id="loading-spinner"></div>
    </div>
  </div>

  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script>
    const map = L.map("map").setView([51.2, 10.5], 6);

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      attribution: "&copy; OpenStreetMap-Mitwirkende",
    }).addTo(map);

    const AIRTABLE_API_KEY =
      "patlyiYzU6HAMUiY9.7cfef1ea6fc2a5cd9cc3acebf1347fd04ba1e1d7dd60e9acc7bb77c0caa72f78";
    const AIRTABLE_BASE = "appGh6rEXtCNMCrWh";
    const AIRTABLE_TABLE = "PLZ%20Status";

    const ZOOM_RANGE = {
      plz1: [6, 6],
      plz2: [7, 8],
      plz3: [9, 10],
      plz5: [11, 20],
      markers: [9, 20],
    };

    let layerPLZ1,
      layerPLZ2,
      layerPLZ3,
      layerPLZ5,
      markerLayer = L.layerGroup();

    const plzFeatures = [];
    const markerFeatures = [];
    const plzStatusCache = {};
    const plzCount = { plz1: 0, plz2: 0, plz3: 0, plz5: 0 };
    let markerCount = 0;

    // UI-Elemente
    const debugText = document.getElementById("debug-text");
    const loadingSpinner = document.getElementById("loading-spinner");

    function inZoomRange(zoom, range) {
      return zoom >= range[0] && zoom <= range[1];
    }

    function sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }

    function updateDebugInfo() {
      debugText.innerText = `PLZ1=${plzCount.plz1}, PLZ2=${plzCount.plz2}, PLZ3=${plzCount.plz3}, PLZ5=${plzCount.plz5}, Marker=${markerCount}`;
    }

    function setLoading(isLoading) {
      loadingSpinner.style.display = isLoading ? "inline-block" : "none";
    }

    function toggleLayer(layer, range) {
      const zoom = map.getZoom();
      if (layer) {
        if (inZoomRange(zoom, range)) {
          if (!map.hasLayer(layer)) map.addLayer(layer);
        } else {
          if (map.hasLayer(layer)) map.removeLayer(layer);
        }
      }
    }

    function updateMarkerVisibility() {
      if (!markerLayer) return;
      const showUnknown = document.getElementById("unknownMarkerToggle").checked;
      const showTTTN = document.getElementById("tttnMarkerToggle").checked;

      markerLayer.eachLayer((marker) => {
        const typ = (marker.feature.properties.Netzform || "").trim().toUpperCase();
        let visible = false;
        if (typ === "TT" || typ === "TN") visible = showTTTN;
        else if (!typ && showUnknown) visible = true;

        marker.setStyle({
          opacity: visible ? 1 : 0,
          fillOpacity: visible ? 1 : 0,
        });
      });
    }

    async function fetchPLZStatusWithRetry(plz, maxRetries = 5) {
      let tries = 0;
      while (tries < maxRetries) {
        tries++;
        const url = `https://api.airtable.com/v0/${AIRTABLE_BASE}/${AIRTABLE_TABLE}?filterByFormula={PLZ}='${plz}'`;
        const res = await fetch(url, {
          headers: { Authorization: `Bearer ${AIRTABLE_API_KEY}` },
        });
        if (res.status === 429) {
          console.warn(
            `Rate limit hit for PLZ ${plz}, retrying in 1000ms (try ${tries})`
          );
          await sleep(1000);
          continue;
        }
        if (!res.ok) {
          console.error(`Fehler bei PLZ ${plz}:`, await res.text());
          return null;
        }
        const json = await res.json();
        return json.records[0]?.fields || null;
      }
      console.error(`Max retries erreicht für PLZ ${plz}`);
      return null;
    }

    async function savePLZStatus(plz, status) {
      // Status in Airtable aktualisieren (PATCH, wenn existiert, sonst POST)
      let recordId = null;

      // Prüfe, ob Datensatz schon im Cache ist
      if (plzStatusCache[plz] && plzStatusCache[plz].recordId) {
        recordId = plzStatusCache[plz].recordId;
      } else {
        // Versuche RecordID von Airtable zu holen
        const url = `https://api.airtable.com/v0/${AIRTABLE_BASE}/${AIRTABLE_TABLE}?filterByFormula={PLZ}='${plz}'`;
        const res = await fetch(url, {
          headers: { Authorization: `Bearer ${AIRTABLE_API_KEY}` },
        });
        if (res.ok) {
          const json = await res.json();
          if (json.records.length > 0) {
            recordId = json.records[0].id;
          }
        }
      }

      const body = JSON.stringify({
        fields: {
          PLZ: plz,
          status: status,
        },
      });

      let method = recordId ? "PATCH" : "POST";
      let url = `https://api.airtable.com/v0/${AIRTABLE_BASE}/${AIRTABLE_TABLE}`;
      if (recordId) url += `/${recordId}`;

      const resUpdate = await fetch(url, {
        method,
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${AIRTABLE_API_KEY}`,
        },
        body,
      });

      if (!resUpdate.ok) {
        console.error(`Fehler beim Speichern für PLZ ${plz}:`, await resUpdate.text());
      } else {
        // Cache updaten
        plzStatusCache[plz] = { status, recordId };
      }
    }

    function updatePLZFeaturesStatus(plz, status) {
      plzFeatures.forEach((layer) => {
        // TT/TN gilt auch für PLZ-Bereiche, Misch nur exakt
        if (
          layer._plz === plz ||
          (status !== "Misch" &&
            plz.length < layer._plz.length &&
            layer._plz.startsWith(plz))
        ) {
          plzStatusCache[layer._plz] = { status };
          layer.setStyle({
            fillColor:
              status === "TT"
                ? "rgba(255,0,0,0.5)"
                : status === "TN"
                ? "rgba(0,255,0,0.5)"
                : status === "Misch"
                ? "rgba(255,165,0,0.5)"
                : "transparent",
            fillOpacity: 0.5,
          });
        }
      });
      updateMarkerVisibility();
    }

    async function loadPLZLayer(url, key, color) {
      const res = await fetch(url);
      const data = await res.json();
      plzCount[key] = data.features.length;

      const layer = L.geoJSON(data, {
        style: (feature) => {
          const plz = feature.properties.plz || "";
          const status = plzStatusCache[plz]?.status || "unbekannt";
          const fillColor =
            status === "TT"
              ? "rgba(255,0,0,0.5)"
              : status === "TN"
              ? "rgba(0,255,0,0.5)"
              : status === "Misch"
              ? "rgba(255,165,0,0.5)"
              : "transparent";
          return { color: "#000", weight: 1.5, fillColor, fillOpacity: 0.5 };
        },
        onEachFeature: async (feature, layer) => {
          const plz = feature.properties.plz;
          if (!plzStatusCache[plz]) {
            const data = await fetchPLZStatusWithRetry(plz);
            if (data) plzStatusCache[plz] = data;
            await sleep(250);
          }
          layer._plz = plz;
          layer._plzKey = key;
          plzFeatures.push(layer);

          const currentStatus = plzStatusCache[plz]?.status || "unbekannt";
          const popupContent = `<strong>PLZ:</strong> ${plz}<br>Status: ${currentStatus}<br>
            <button class='status-button' onclick="setPLZStatus('${plz}', 'TT')">TT</button>
            <button class='status-button' onclick="setPLZStatus('${plz}', 'TN')">TN</button>
            <button class='status-button' onclick="setPLZStatus('${plz}', 'Misch')">Misch</button>`;
          layer.bindPopup(popupContent);
          layer.bindTooltip(plz, {
            permanent: inZoomRange(map.getZoom(), ZOOM_RANGE[key]),
            direction: "center",
            className: "plz-label",
          });
        },
      });
      return layer;
    }

    async function loadMarkers() {
      // Dummy: Marker laden - hier kannst du den echten GeoJSON-Pfad einfügen
      const url =
        "https://christoph-staudacher.github.io/Netzkartendaten/Netzformen.geojson";
      const res = await fetch(url);
      const data = await res.json();
      markerCount = data.features.length;

      markerLayer.clearLayers();

      data.features.forEach((feature) => {
        const latlng = L.latLng(
          feature.geometry.coordinates[1],
          feature.geometry.coordinates[0]
        );
        const typ = (feature.properties.Netzform || "").trim().toUpperCase();

        let color = "gray";
        let opacity = 0.5;
        if (typ === "TT") {
          color = "red";
          opacity = 1;
        } else if (typ === "TN") {
          color = "green";
          opacity = 1;
        }

        const marker = L.circleMarker(latlng, {
          radius: 6,
          color,
          fillColor: color,
          fillOpacity: opacity,
          weight: 1,
        }).bindPopup(`<strong>Netzform:</strong> ${typ || "Unbekannt"}`);

        markerLayer.addLayer(marker);
        markerFeatures.push(marker);
      });
    }

    function updateTooltips() {
      const zoom = map.getZoom();
      const bounds = map.getBounds();

      plzFeatures.forEach((layer) => {
        const inRange = inZoomRange(zoom, ZOOM_RANGE[layer._plzKey] || [0, 0]);
        const visibleInMap = bounds.intersects(layer.getBounds());
        const showTooltip = inRange && visibleInMap;

        if (showTooltip && !layer._tooltipAdded) {
          layer.bindTooltip(layer._plz, {
            permanent: true,
            direction: "center",
            className: "plz-label",
            opacity: 1,
          });
          layer._tooltipAdded = true;
        }
        if (layer.getTooltip()) {
          const el = layer.getTooltip().getElement();
          if (el) el.style.display = showTooltip ? "block" : "none";
        }
      });
    }

    function applyMarkerFilter() {
      if (!markerLayer) return;
      const showUnknown = document.getElementById("unknownMarkerToggle").checked;
      const showTTTN = document.getElementById("tttnMarkerToggle").checked;

      markerLayer.eachLayer((layer) => {
        const rawTyp = (layer.feature.properties.Netzform || "").trim().toUpperCase();

        let visible = false;
        let color = "gray";
        let opacity = 0.5;

        if (rawTyp === "TT") {
          color = "red";
          opacity = 1;
          visible = true;
        } else if (rawTyp === "TN") {
          color = "green";
          opacity = 1;
          visible = true;
        } else if (rawTyp === "" || rawTyp == null) {
          visible = showUnknown;
        }

        layer.setStyle({
          color,
          fillColor: color,
          opacity: visible ? 1 : 0,
          fillOpacity: visible ? opacity : 0,
        });
      });
    }

    function zoomToPLZ() {
      const input = document.getElementById("plzInput").value.trim();

      plzFeatures.forEach((layer) => {
        layer.setStyle({ fillColor: "transparent", fillOpacity: 0, color: "#000", weight: 1.5 });
      });

      // Suche exakte PLZ
      const found = plzFeatures.find((l) => l._plz === input);

      if (found) {
        map.fitBounds(found.getBounds(), { maxZoom: 12 });
        found.openPopup();
        found.setStyle({ fillColor: "yellow", fillOpacity: 0.3, color: "#333", weight: 2 });
        analyzeMarkersInPolygon(found);
      } else {
        alert("PLZ nicht gefunden oder noch nicht geladen.");
        document.getElementById("marker-info").innerText = "";
      }
    }

    function analyzeMarkersInPolygon(layer) {
      if (!markerLayer) return;
      const bounds = layer.getBounds();
      let countAll = 0,
        countTT = 0,
        countTN = 0,
        countUnknown = 0;

      markerLayer.eachLayer((marker) => {
        if (bounds.contains(marker.getLatLng())) {
          countAll++;
          const typ = (marker.feature.properties.Netzform || "").trim().toUpperCase();
          if (typ === "TT") countTT++;
          else if (typ === "TN") countTN++;
          else countUnknown++;
        }
      });

      const totalKnown = countTT + countTN;
      const ratio = totalKnown > 0 ? ((countTT / totalKnown) * 100).toFixed(1) + "%" : "n.v.";
      document.getElementById(
        "marker-info"
      ).innerText = `Im PLZ-Bereich ${layer._plz} sind ${countAll} Marker // Davon ${countTT} TT, ${countTN} TN und ${countUnknown} Unbekannt. TT-Anteil: ${ratio}`;
    }

    // --- NEU: Hilfsfunktion um enthaltene PLZ zu generieren ---
    function generateContainedPLZ(plz) {
      const len = plz.length;
      const results = [];

      if (len === 2) {
        // Für 2-stellige PLZ: alle 3-,4-,5-stelligen PLZs mit diesem Präfix
        for (let i = 0; i <= 9; i++) {
          results.push(plz + i); // 3-stellig, z.B. "990"
        }
        for (let i = 0; i <= 99; i++) {
          results.push(plz + i.toString().padStart(2, '0')); // 4-stellig, "9900"
        }
        for (let i = 0; i <= 999; i++) {
          results.push(plz + i.toString().padStart(3, '0')); // 5-stellig, "99000"
        }
      } else if (len === 3) {
        // Für 3-stellige PLZ: alle 4- und 5-stelligen mit diesem Präfix
        for (let i = 0; i <= 9; i++) {
          results.push(plz + i); // 4-stellig
        }
        for (let i = 0; i <= 99; i++) {
          results.push(plz + i.toString().padStart(2, '0')); // 5-stellig
        }
      } else if (len === 1) {
        // Für 1-stellige PLZ: alle 2-, 3-, 4-, 5-stelligen mit dem Präfix
        for (let i = 0; i <= 9; i++) {
          results.push(plz + i); // 2-stellig
        }
        for (let i = 0; i <= 99; i++) {
          results.push(plz + i.toString().padStart(2, '0')); // 3-stellig
        }
        for (let i = 0; i <= 999; i++) {
          results.push(plz + i.toString().padStart(3, '0')); // 4-stellig
        }
        for (let i = 0; i <= 9999; i++) {
          results.push(plz + i.toString().padStart(4, '0')); // 5-stellig
        }
      }

      return results;
    }

    // --- NEU: Angepasste setPLZStatus mit erweiterten PLZ-Bereichen ---
    window.setPLZStatus = async function (plz, status) {
      setLoading(true);

      // Erstelle Liste der PLZs, die aktualisiert werden sollen
      let plzToUpdate = [plz];

      // Wenn TT oder TN, erweitere um alle Unter-PLZ
      if (status === "TT" || status === "TN") {
        // Nur für PLZ 1,2 oder 3-stellig erweitern
        if (plz.length <= 3) {
          const contained = generateContainedPLZ(plz);
          plzToUpdate = [...new Set([...plzToUpdate, ...contained])];
        }
      }

      // Aktualisiere alle PLZ in Airtable nacheinander mit Pause
      for (const p of plzToUpdate) {
        await savePLZStatus(p, status);
        updatePLZFeaturesStatus(p, status);
        await sleep(250); // Rate Limit Pause
      }

      setLoading(false);
    };

    async function fetchVisiblePLZStatuses(geojsonLayer, plzKey) {
      const zoom = map.getZoom();
      const bounds = map.getBounds();

      const visibleFeatures = geojsonLayer.getLayers().filter((layer) => {
        if (!inZoomRange(zoom, ZOOM_RANGE[plzKey])) return false;
        if (!bounds.intersects(layer.getBounds())) return false;
        return true;
      });

      for (const layer of visibleFeatures) {
        const plz = layer._plz;
        if (!plzStatusCache[plz]) {
          setLoading(true);
          const statusData = await fetchPLZStatusWithRetry(plz);
          if (statusData) {
            plzStatusCache[plz] = statusData;
            const status = statusData.status || "unbekannt";
            layer.setStyle({
              fillColor:
                status === "TT"
                  ? "rgba(255,0,0,0.5)"
                  : status === "TN"
                  ? "rgba(0,255,0,0.5)"
                  : status === "Misch"
                  ? "rgba(255,165,0,0.5)"
                  : "transparent",
              fillOpacity: 0.5,
            });
          }
          updateDebugInfo();
          await sleep(250);
        }
      }
      setLoading(false);
    }

    async function loadAll() {
      setLoading(true);

      layerPLZ1 = await loadPLZLayer(
        "https://christoph-staudacher.github.io/Netzkartendaten/plz-1stellig.geojson",
        "plz1",
        "#999"
      );
      layerPLZ2 = await loadPLZLayer(
        "https://christoph-staudacher.github.io/Netzkartendaten/plz-2stellig.geojson",
        "plz2",
        "#666"
      );
      layerPLZ3 = await loadPLZLayer(
        "https://christoph-staudacher.github.io/Netzkartendaten/plz-3stellig.geojson",
        "plz3",
        "#444"
      );
      layerPLZ5 = await loadPLZLayer(
        "https://christoph-staudacher.github.io/Netzkartendaten/plz-5stellig.geojson",
        "plz5",
        "#333"
      );

      markerLayer = L.layerGroup();
      await loadMarkers();
      markerLayer.addTo(map);

      [layerPLZ1, layerPLZ2, layerPLZ3, layerPLZ5].forEach((layer) => {
        if (map.hasLayer(layer)) map.removeLayer(layer);
      });

      updateDebugInfo();

      map.on("zoomend moveend", async () => {
        toggleLayer(layerPLZ1, ZOOM_RANGE.plz1);
        toggleLayer(layerPLZ2, ZOOM_RANGE.plz2);
        toggleLayer(layerPLZ3, ZOOM_RANGE.plz3);
        toggleLayer(layerPLZ5, ZOOM_RANGE.plz5);
        toggleLayer(markerLayer, ZOOM_RANGE.markers);

        updateTooltips();

        await fetchVisiblePLZStatuses(layerPLZ1, "plz1");
        await fetchVisiblePLZStatuses(layerPLZ2, "plz2");
        await fetchVisiblePLZStatuses(layerPLZ3, "plz3");
        await fetchVisiblePLZStatuses(layerPLZ5, "plz5");

        updateMarkerVisibility();
        updateDebugInfo();
      });

      map.fire("zoomend");
      map.fire("moveend");

      setLoading(false);
    }

    document
      .getElementById("unknownMarkerToggle")
      .addEventListener("change", updateMarkerVisibility);
    document
      .getElementById("tttnMarkerToggle")
      .addEventListener("change", updateMarkerVisibility);

    window.zoomToPLZ = zoomToPLZ;

    // Karte laden
    loadAll();
  </script>
</body>
</html>
